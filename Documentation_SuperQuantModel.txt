 
 

         _________________________________________________
       _|                                         |       |
      /                                           |       |
      \_     S U P E R C O N D U C T I N G        X     __|__
      /                                           |     _____
      \_            Q U A N T U M                 X       |
      /                                           |    ___|___
      \_            C I R C U I T                 X   |       |
      /                                           |   X       x
      \_              M O D E L                   X   |_______|
        |     | |                                 |       |
        |_____| |________\/_______________________|_______|
              | |        /\   (c) Andrey Klots
              | |           







                      *******************************
                      *******************************
                      **                           **
                      **   C O D E   S Y N T A X   **
                      **                           **
                      *******************************
                      *******************************
  This section describes syntax of a code defining
superconducting circuit. Following codes are considered:
1. Circuit Code: describes structure of the circuit.
2. Mutual Inductance Code: describes mutual inductances
                                     between inductors.
3. Flux Bias Code: describes flux biases inside inductors.
4. Charge Bias Code: describes charge biases on the nodes.



     ______________
    | CIRCUIT CODE |
    |______________|
      Code syntax: syntax to describe the structure of a circuit
    Circuit is defined by listing elements of a circuit along
    with terminal(node) numbers that these elements connect.

    CircuitCode = [ \
                      [T1_1, T2_1, Element_1, Value_1], \
                      [T1_2, T2_2, Element_2, Value_2], \
                        ...
                      [T1_N, T2_N, Element_N, Value_N]  \                            
                  ]
    
    Parameters of the code:
    Element_n (str) -- determines type of the n-th element. Possible values:
                         "L": Inductor
                         "C": Capacitor
                         "J": Josephson junction
                        "J$": Higher-order Josephson junction allowing 
                              tunneling of multiple Cooper pairs. The
                              phase-energy relation of such junction is
                              E(phi) = E_J * cos($*phi). Here $ is an integer.
                              Example codes are: "J1" -- equivalent to "J"
                                                 "J2" -- pi-periodic element
                                                 "J3" -- tunneling of 3 pairs
                                                 "J0" -- just constant energy
                                                                       offset
                               NOTE: integer has to be written right after "J"
                                     formulas "J0", "J123", "J-245" are OK
                                     formulas "J 1", "J2.0" are not OK
                        NOTE: Capitalization matters: formulas like
                              "c", "l", "j" or "j2" will not work
                              
    T1_n, T2_n (int >=0) -- numbers of terminals (nodes) to which element
                        Element_n is connected.
                        
                        There should be no missing terminal numbers. I.e., if
                        circuit has 10 nodes (except ground) then every number
                        between 1 and 10 (inclusive) has to be present among T1
                                                                         and T2.
                        Ground terminal (ground node) corresponds to T1_n = 0
                                                                  or T2_n = 0
                        
    Value_n (float) -- value corresponding to n-th element.
                If Element_n=="L" then Value needs to be inductance
                If Element_n=="C" then Value needs to be capacitance
                If Element_n=="J" or "J$" then Value needs to be 
                                               Josephson energy E_J so 
                                               that potential is E_J*cos($*phi)
    
    
    NOTE: Every node of the circuit has to be connected to ground through
          at least some chain of inductors and/or Josephson junctions (even if
                              those Josephson junctions have zero energy).
          Failure to build circuit in such way creates charge islands/clusters
          with ill-defined charge quantization. Zero-energy junctions provide
                                                measure of the charge quantum.
          Also, any circuit has to contain at least one inductor(however small)






     ________________________
    | MUTUAL INDUCTANCE CODE |
    |________________________|
      Mutual inductance is defined by listing terminal numbers to which each
    inductor is connected along with mutual inductance values.

    Code Syntax:
    MutualInductanceCode = [ \
                            [T1a_1, T2a_1, T1b_1, T2b_1,     MutualInd_1], \
                            [T1a_2, T2a_2, T1b_2, T2b_2,     MutualInd_2], \
                               ...
                            [T1a_M, T2a_M, T1b_M, T2b_M,     MutualInd_2]
                           ]
    Parameters:
    MutualInd_n (float): n-th mutual inductance between inductors a_n and b_n.
    T1a_n, T2a_n, T1b_n, T2b_n (int >=0) -- terminal numbers identifying
                                            the two inductors:
                                            inductor a_n is identified by the
                                            nodes that it connects.
                                            i.e. inductor a_n connects
                                            terminals T1a_n and T2a_n and
                                            inductor b_n connects
                                            terminals T1b_n and T2b_n.
                                            NOTE: terminals T1, T2 should be
                                                  in same order as in 
                                                                 CircuitCode.
    If mutual inductances are not set in this code then no mutuals exist in
    the circuit.
 
    
    
    
    
     ________________
    | FLUX BIAS CODE |
    |________________|
    Code Syntax:
    FluxBiasCode = [\
                    [T1_1, T2_1, Flux_1],  \
                    [T1_2, T2_2, Flux_2],  \
                         ...
                   ]
    Parameters:
    T1_n, T2_n (int >=0) -- terminal numbers that identify the n-th inductor.
                            I.e. Inductor connects nodes T1 and T2.
                            Order should be same as in CircuitCode. E.g., if
                            CircuitCode has a line [2,3, "L", 10], then it
                            needs to be addressed with setting T1=2 and T2=3, 
                            and not T1=3, T2=2.
    Flux_n (float): flux bias in n-th inductor
    
    If flux bias is not set for an inductor then it is zero by default.
    




     __________________
    | CHARGE BIAS CODE |
    |__________________|
    Code Syntax:
    ChargeBiasCode = [\
                      [T_1, Charge_1],  \
                      [T_2, Charge_2],  \
                         ...
                     ]
    Parameters:
    T_n (int >0) -- terminal (node) number to which charge bias is applied.
    Charge_n (float): charge bias value in n-th node
    If charge bias is not set for a node then it is zero by default.

     ___________
    | N O T E ! |
    |___________|
    
    UNITS: The system works in units of 
                                        h_bar = 2e = Phi_0/(2pi) = 1
                                        Energy is then the only undefined
                                        unit and needs to be set by the user.
                                        Default suggestion is 1[Kelvin] = 1.
            One can use MicrowaveUnits module for making unit system more
            user-friendly.






______________________________________________________________________________

                      *****************************
                      *****************************
                      **                         **
                      **  D E S C R I P T I O N  **
                      **                         **
                      **           O F           **
                      **                         **
                      **      C L A S S E S      **
                      **                         **
                      *****************************
                      *****************************

           NOTE:     This section is structured as follows:
                  I describe classes, methods and functions. 
                  Names of functions or methods are marked with brackets
                  like "someFunction(Arguments)". Without brackets,
                  it is either class or property. Classes and properties
                  are accompanied with a brief description. Internal 
                  structures of classes/properties are showed by tabulation.
                     Any function/method is accompanied with a brief
                  description of what it does and what variables,
                  inputs, outputs it requires or modifies.
                     In the description of a function/method following
                  descriptors are used:
                  "in:" -- describes arguments of a function
                  "requires" -- sometimes function does not require explicit
                                argument and works with properties of the
                                class that are required to be set before
                                function/method can be executed. This section
                                describes which properties are used by a 
                                function/method.
                  "return:" -- describes what value function returns
                  "modifies:" -- sometimes function/method can not only
                                 return a value, but also modify existing
                                 properties of a class. This section describes
                                 which properties are modified.
                  
  *******************
  *  S U M M A R Y  *
  *       O F       *
  *  C L A S S E S  *
  *******************



>  USEFUL FUNCTIONS  
dirv(Obj)    [show main properties and methods inside class]
_print_text_in_line(Text, [color]) [print colored text w/o going to new line]
eigsort(A, [METHOD])  [returns sorted eigenvalues of matrix A]
KRONTYPE     [varible describes how to calculate direct products of matrices]
MDkron(A,B)  [claculate direct product of matrices A and B]

>  BIG CLASS: Circuit Parameters
CircuitParameters [class describes basic circuit parameters]
|__ Inv_sqrt_C [(Maxwell capacitance matrix)^(-1/2) ]
|__ G          [matrix describing connectivity of inductors]
|__ Inv_L      [(Inductance matrix)^-1 ]
|__ H          [connectivity matrix of Josephson junctions]
|__ E_jos      [list: Josephson junction energies]
|__ Phi        [list: flux offsets in inductors]
|__ Q          [list: charge offsets on islands]




>  BIG CLASS: Model Calculator  
ModelCalculator [class]
|__ SMALL [small parameter to distinguish zero frequencies]
|
|__ Circuit [object of class CircuitParameters]    
|
|__ Matrices [class that contains matrices needed for 
|   |         coordinate transformations]
|   |__ U   [unitary matrix: untangles harmonic oscillators]
|   |__ omega_eigenvalues   [array (vector) of frequency modes]
|   |__ N_cyc    [int, $N^{cyc}$]
|   |__ N_osc    [int, $N^{osc}$]
|   |__ M        [matrix defining values inside 
|   |             cosines of Josephson potentials ($M$)]
|   |__ M_cyc    [cyclic part of M ($\mathbb{M}^{cyc}$)]
|   |__ M_osc    [oscillatory part of M ($\mathbb{M}^{osc}$)]
|   |__ m_cyc    [largest invertible submatrix of M_cyc]
|   |__ Z_cyc    [matrix: integer factorization of M_cyc]
|   |__ F        [column-vector: transformed flux biases]
|   |__ K        [column-vector: transformed charge biases]
|__ calc_U_omega_eigenvalues() [get oscillator modes of circuit]
|__ calc_N_cyc_osc_tot() [get # of cyclic and oscillator coordinates]
|__ calc_M()          [used for coordinate transformations]
|__ calc_M_cyc_osc()          [--//--]
|__ calc_m_cyc()              [--//--]
|__ calc_Z_cyc(ENFORCE_INT)   [--//--]
|__ calc_Transformed_Flux_Charge_Biases()
|__ getTransform1Matrix() [returns matrix making transform I]
|__ getTransform2Matrix() [returns matrix making transform II]
|__ getTransform3Matrix() [returns matrix making transform III]
|__ getHamiltonianParameters3() [returns Hamiltonian parameters
|     $\mathbb{c}^{-1}$, $\sqrt{\omega}$ and M^(III) after transform III]
|
|__ Operators [class that contains quantum operators]
|   |__ I_hat [list of identity operators for transformed coordinates]
|   |__ N_hat [list of number operators for coordinates]
|   |__ V_hat [list of Josephson junction energy operators]
|   |__ N_of_states [list:number of quant. states for each coordinate]
|   |__ Hamiltonian [Hamiltonian (matrix)]
|__ obtainOperators(DISPLAY_PROGRESS=True) [calc. I,N,V-operators]
|__ obtainHamiltonian(DISPLAY_PROGRESS=True) [construct Hamiltonian]
|__ getTotal_N_of_states() [returns total number of quantum states]
|
|     USEFUL FUNCTION: extract largest nonsingular submatrix of mat. A
|__ getMaxInvertibleSubmatrix(A[matrix], [TOLERANCE])



        
>  BIG CLASS: Circuit Builder
CircuitBuilder [class]
|__ SMALL [small parameter defining minimal capacitance]
|
|__ Circuit [class describing the circuit]
|   |__ Code    [list: Code describing the circuit structure]
|   |__ MutualInductanceCode    [list: Code describing mutual inductances]
|   |__ C       [Maxwell capacitance matrix]
|   |__ L       [Inductance matrix]
|   |__ E_jos   [row/column-vector of Josephson energies]
|   |__ extract(ElementType) [extracts code rows for L's, JJ's or C's]
|   |__ nElements() [return # of elements in code(lines in Circuit.Code)]
|   |__ size()      [return number of nodes in a circuit] 
|   |__ findElementNumber(self, Node1,Node2, ElementType) [find element(L, 
|                                           JJ, by nodes that it connects]
|
|__ setCapacitanceMatrix() [calculate capacitance matrix Circuit.C]
|__ setInductanceMatrix()  [calculate inductance matrix Circuit.L]
|__ setJosephsonEnergies() [set Circuit.E_jos values from Circuit.Code]
|__ getInductorConnectivityMatrixG() [returns inductor connectivity mat.]
|__ getJosephsonConnectivityMatrixH() [returns JJ connectivity matrix]
|__ getFluxBiasVector(FluxBiasCode) [FluxBiasCode-->vector of flux biases]
|__ getChargeBiasVector(ChargeBiasCode)
|__ obtainConnectivityMatrix(Circuit, ElementType)
|__ convertMutualMaxwellCapMat(C) [converts Mutual<-->Maxwell cap.matrices]
|__ inv_sqrt(C, SMALL) [returns inverse sqrt of capacitance matrix]




>  BIG CLASS: Easy Model -- helps automatize calculations
EasyModel(SMALL, CircuitCode, MutualInductanceCode) [class]
|
|__ SMALL   [positive float: small parameter used in the model]
|__ MESSAGE_ARRAY   [list of messages saved in progress] 
|__ DISPLAY  [bool:display messages on screen when calling printMessage?]
|__ ENFORCE_INT_IN_Z_CYC [bool: enforce Z_cyc to be integer?]
|__ DEBUG_DATA  [dictionary of intermediate values for debugging]
|
|__ SQM [class that contains CircuitBuilder and ModelCalculator objects]
|   |__ CircBuild [object of class CircuitBuilder]
|   |__ ModelCalc [object of class ModelCalculator]
|
|__ Code [class that contains codes describing all circuit parameters]
|   |__ CircuitCode [list: Code describing circuit structure]
|   |__ MutualInductanceCode [list: Code describing mutual inductances]
|   |__ FluxBiasCode [list: Code describing flux biases]
|   |__ ChargeBiasCode [list: Code describing charge biases]
|
|__ printMessage(Message) [save Message to MESSAGE_ARRAY or print on screen]
|__ buildCircuit() [calculate all circuit parameters from code]
|__ transformCoordinates() [perform coordinate transformations]
|__ transformBiasVectors(FluxBiasCode, ChargeBiasCode)
|__ summarizeCoord() [display summary of coordinate properties]
|__ set_N_of_states(N_of_states) [set # of quantum states to be used]
|__ setOperators() [obtain quantum operators in SQM.CircBuild.Operators]
|__ setHamiltonian() [obtain Hamiltonian in SQM.CircBuild.Operators]
|__ getHamiltonian() [return Hamiltonian from SQM.CircBuild.Operators]


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////




  ***************************
  *     D E T A I L E D     *
  *  D E S C R I P T I O N  *
  *           O F           *
  *      C L A S S E S      *
  ***************************

========================
 ____________________
|                    |
|  USEFUL FUNCTIONS  |
|____________________|

========================
dirv(Obj)
    ------------------------------------------------------------------
    *** View structure of object without hidden properties/methods ***
    ------------------------------------------------------------------
    [in: Obj (object/class)
     return: results of a dir-function, but omits all properties/methods 
             starting with "_". returns structure of element Obj]
    

_print_text_in_line(Text, color)
    ------------------------------------------------------------------
    *** Print colored text in console w/o going to new line***
    ------------------------------------------------------------------
    [in: Text (string) -- text to print
         color (int, optional) -- color to use for the text. Default: None
     return: None -- prnts in console]


eigsort(A, [METHOD])
     --------------------------
     *** Diagonalize matrix ***
     --------------------------
     [in: A (matrix), METHOD (None or str)
             If METHOD==None/"A"/"a"/"arbitrary" then algorithm diagonalizes
                                                 arbitrary matrix and sorts
                                                 real parts of eigenvalues
             If METHOD=="R"/"r"/"real" then extract real-symmetric part of
                                                 the matrix and diagonalizes it
             If METHOD=="H"/"h"/"Hermit"/"hermit" then extract hermitian part
                                                 of the matrix and diagonalize
             Following methods use the scipy module instead of numpy:
                METHOD=="sparseH999" -- same as METHOD=="H" but extracts
                                                 only first 999 of eigenvalues.
                                                 User can replace the
                                                 number 999 by any number of
                                                 lowest eigenvalues needed.
                METHOD=="sparse999" -- same as METHOD==None but extract only
                                                 first 999 (or other number)
                                                 of lowest eigenvalues.
      return: D (column-vector of eigenvalues of A sorted
                                with increasing real part)
              U (column-eigenvectors).] 



KRONTYPE
    ----------------------------------------------------
    *** Method to use for direct product of matrices ***
    ----------------------------------------------------
    Variable describing a whether to use numpy module or
                                         scipy.sparse to
                                         calculate direct products.
    [values: KRONTYPE = "numpy"/"np"          -- use numpy
             KRONTYPE = "scipy"/"sp"/"sparse" -- use scipy.sparse.
                                                 sparse is needed to
                                                 multiply large matrices. ]


MDkron(A,B)
    --------------------------------------------------------
    *** Function to calculate direct product of matrices ***
    --------------------------------------------------------
    This function will be used in the classes below.
    For direct roducts of few large matrices
    (or of many small matrices) one needs to
    set KRONTYPE = "scipy"
    [in:       A, B (matrix)
     requires: KRONTYPE (str)
     return:   direct product of matrices A and B calculated
                    using either numpy module or scipy.sparse,
                    depending on the value of KRONTYPE ]



=====================================
 _________________________________
|                                 |
|  BIG CLASS: Circuit Parameters  |
|_________________________________|
|
| This class stores essential 
| properties of the circuit.
| Information contained here
| is sufficient to fully describe
| the circuit and fully sufficient
| to perform calculations
=====================================
CircuitParameters [class]
|   ------------------------------------
|   *** Essential circuit parameters ***
|   ------------------------------------
|__ Inv_sqrt_C
|       [matrix: square root of inverce Maxwell capacitance matrix $C^{-1/2}$]
|__ G
|       [inductor connectivity matrix. 
|        Dimensions: (N of inductors) x (N of nodes)]
|__ Inv_L
|       [inverse inductance matrix. 
|        Dimensions: (N of inductors) x (N of inductors)]
|__ H
|       [matrix: Josephson connectivity matrix. 
|        Same as Inductance capacitance matrix, but for Josephson junctions]
|__ E_jos
|       [column-vector or list: array(column-vector) of Josephson energies]
|__ Phi
|       [column-vector of offset fluxes]
|__ Q
        [column-vector of offset charges]








===================================
 _______________________________
|                               |
|  BIG CLASS: Model Calculator  |
|_______________________________|
|
| This class contains methods
| to perform coordinate 
| transformations and generate
| quantum operators
| for building the Hamiltonian
===================================
ModelCalculator [class]
|   -----------------------------------------------
|   *** Class used to build quantum Hamiltonian ***
|   -----------------------------------------------
|
|__ SMALL
|       [small number. numbers smaller than that will be considered 
|        effectively zero. Used to compare vectors and 
|        find zero frequency modes]
|    __________
|   | SUBCLASS |
|   |__________|
|__ Circuit [object of class CircuitParameters]    
|    __________
|   | SUBCLASS |
|   |__________|
|__ Matrices [class that contains matrices needed for 
|   |         coordinate transformations]
|   |__ U   [unitary matrix for first coordinate transformation:
|   |        untangles harmonic oscillators]
|   |__ omega_eigenvalues   [array (vector) of frequency modes]
|   |__ N_cyc    [int, $N^{cyc}$]
|   |__ N_osc    [int, $N^{osc}$]
|   |__ M        [matrix defining values inside 
|   |             cosines of Josephson potentials ($M$)]
|   |__ M_cyc    [cyclic part of M ($\mathbb{M}^{cyc}$)]
|   |__ M_osc    [oscillatory part of M ($\mathbb{M}^{osc}$)]
|   |__ m_cyc    [largest invertible submatrix of M_cyc ($\mathbb{m}^{cyc}$).
|   |             Used for second coordinate transform]
|   |__ Z_cyc    [matrix: integer form of M_cyc after 
|   |             transformation ($\mathbb{Z}^{cyc}$). Z_cyc=int(M_cyc/m_cyc)]
|   |__ F        [column-vector: transformed flux biases 
|   |             MatrixCalculator.Circuit.Phi --> MatrixCalculator.Matrices.F]
|   |__ K        [column-vector: transformed charge biases 
|                 MatrixCalculator.Circuit.Q --> MatrixCalculator.Matrices.K]
|   
|__ calc_U_omega_eigenvalues()
|       ------------------------------------------------------------
|       *** Calculate matrices for transformation I. Diagonalize ***
|       *** harmonic oscillators                                 ***
|       ------------------------------------------------------------
|       [requires: Circuit.Inv_sqrt_C, Circuit.Inv_L, Circuit.G
|        modifies: Matrices.U, Matrices.omega_eigenvalues]
|__ calc_N_cyc_osc_tot()
|       ------------------------------------------------------------
|       *** Distinguish cyclic coordinates from oscillatory ones ***
|       ------------------------------------------------------------
|       [requires: Matrices.omega_eigenvalues, SMALL
|        modifies: Matrices.N_cyc (sets number of cyclic coordinates with
|                                                      frequencies < SMALL
|                  Matrices.N_osc (number of oscillatory coordinates 
|                                                          N_tot - N_cyc)]
|__ calc_M()
|       --------------------------
|       *** Calculate M-matrix ***
|       --------------------------
|       [requires: Circuit.H, Circuit.Inv_sqrt_C, Matrices.U
|        modifies: calculates Matrices.M]
|__ calc_M_cyc_osc()
|       ----------------------------------------------------------------------
|       *** Split M-matrix into cyclic(M_cyc) and oscillatory(M_osc) parts ***
|       ----------------------------------------------------------------------
|       [requires: Matrices.M, Matrices.N_cyc, Matrices.N_osc 
|        modifies: calculates Matrices.M_cyc and Matrices.M_osc]
|__ calc_m_cyc()
|       ---------------------------------------------
|       *** Calculate m_cyc for transformation II ***
|       ---------------------------------------------
|       [requires: Matrices.M_cyc, SMALL
|        modifies: extracts linearly-independent rows of M_cyc and saves into 
|                  ModelCalculator.Matrices.m_cyc]
|__ calc_Z_cyc(ENFORCE_INT)
|       -------------------------------------
|       *** calculate Z_cyc = M_cyc/m_cyc ***
|       -------------------------------------
|       [in: ENFORCE_INT (bool: enforce Z_cyc to be integer valued. Default: T)
|        requires: Matrices.M_cyc, Matrices.m_cyc
|        modifies: Matrices.Z_cyc]
|__ calc_Transformed_Flux_Charge_Biases()
|       ----------------------------------------------------
|       *** calculate transformed flux and charge biases ***
|       ----------------------------------------------------
|       [requires: Circuit.Phi, Circuit.Q, Circuit.G, Circuit.H,
|                  Matrices.m_cyc, Circuit.Inv_sqrt_C
|        modifies: Matrices.F, Matrices.K -- transformed flux and charge bias
|                                                              column-vectors]
|
|__ getTransform1Matrix()
|       -----------------------------------------------------
|       *** returns matrix that acting on original phase  ***
|       *** coordinates performs transformation I         ***
|       -----------------------------------------------------
|       [requires: Matrices.U, Circuit.Inv_sqrt_C
|        return:   Martrices.U.T*Circuit.Inv_sqrt_C.T ]
|__ getTransform2Matrix()
|       -----------------------------------------------------
|       *** returns matrix that acting on original phase  ***
|       *** coordinates performs transformation II        ***
|       -----------------------------------------------------
|       [requires: Matrices.U, Matrices.N_cyc,N_osc, Matrices.m_cyc,
|                  Circuit.Inv_sqrt_C
|        return:   matrix that transforms original phases into transformed ]
|__ getTransform3Matrix()
|       -----------------------------------------------------
|       *** returns matrix that acting on original phase  ***
|       *** coordinates performs transformation III       ***
|       -----------------------------------------------------
|       [requires: Matrices.U, Matrices.N_cyc,N_osc, Matrices.m_cyc,
|                  Matrices.omega_eigenvalues, Circuit.Inv_sqrt_C
|        return:  matrix that transforms original phases into transformed ]
|__ getHamiltonianParameters3()
|       --------------------------------------------------------------
|       *** returns some parameters of Hamiltonian after           ***
|       *** transformation III: $\mathbb{c}^{-1}$ and $M^{(III)}$  ***
|       --------------------------------------------------------------
|       [requires: Matrices.U, Matrices.N_cyc,N_osc, Matrices.m_cyc,
|                  Matrices.Z_cyc, Matrices.M_osc,
|                  Matrices.omega_eigenvalues, Circuit.Inv_sqrt_C
|        return:   Tuple of: Inverse capacitance matrix
|                  for transformed cyclic coordinates,
|                  list of square-root oscillator frequencies
|                  and M^(III)-matrix
|                  of coeffitinets inside JJ cosines after transform 3]
|
|    __________
|   | SUBCLASS |
|   |__________|
|__ Operators [class that contains quantum operators]
|   |__ I_hat
|   |       [list of unity matrices for each coordinate
|   |        (i.e. quantum degree of freedom)]
|   |__ N_hat
|   |       [list of number operators (cyclic or oscillatory) for each 
|   |        coordinate. Note that for n-th cyclic coordinate dimensions of
|   |        operators are 2*N_of_states[n]+1; For oscillatory coordinate:
|   |                   just N_of_states[n] ]
|   |__ V_hat
|   |       [list of exponential operators exp(i[coefficient]phi) written 
|   |        in the basis of number operators eigenvectors. Dimension of 
|   |        the list: (N of Josephson junctions) x (N of nodes(coordinates))]
|   |__ N_of_states
|   |       [list of numbers of quantum states for each coordinate.
|   |        For each variable this list sets number of quantum states. 
|   |        For oscillatory coordinates number of quantum state is same as 
|   |        set by N_of_states. For cyclic coordinates, number of
|   |        quantum states will be 2N+1 that]
|   |__ Hamiltonian
|           [Hamiltonian matrix]
|__ obtainOperators(DISPLAY_PROGRESS=True)
|       -------------------------------------------------------
|       *** Calculate quantum operators I_hat, N_hat, V_hat ***
|       -------------------------------------------------------
|       [in: DISPLAY_PROGRESS (bool: display the progress of calculation of
|                              exponential operators. Default: True)
|        requires: Matrices.N_cyc, Matrices.N_osc, Operators.N_of_states,
|                  Matrices.Z_cyc, Matrices.M_osc, Matrices.omega_eigenvalues
|        modifies: obtains lists of operators Operators.I_hat,
|                                             Operators.N_hat,
|                                             Operators.V_hat.
|                  NOTE: these operators are independent on flux/charge biases.
|                        Since calculating these matrices may be
|                        time-consuming, option DISPLAY_PROGRESS determines
|                        if user wants to monitor the progress on the screen]
|__ obtainHamiltonian(DISPLAY_PROGRESS=True)
|       -------------------------------------------------------
|       *** Build Hamiltonian out of operators and Matrices ***
|       -------------------------------------------------------
|       [in: DISPLAY_PROGRESS (bool: display the progress)
|        requires: Matrices.N_cyc, Matrices.N_osc, Matrices.m_cyc,
|                  Matrices.omega_eigenvalues, Circuit.E_jos, Operators.I_hat,
|                  Operators.N_hat, Operators.V_hat, Matrices.F, Matrices.K
|        modifies: obtains Operators.Hamiltonian.
|                  NOTE: Hamiltonian depends on flux/charge
|                        biases set in Matrices.F/K]
|__ getTotal_N_of_states()
|       --------------------------------------------------------------
|       *** get total number of states (dimensions of Hamiltonian) ***
|       --------------------------------------------------------------
|       [requires: Matrices.N_cyc, Matrices.N_osc, Operators.N_of_states
|        return: (int) total number of quantum states of the system
|                      (dimensions of the Hamiltonian)]
|
|    _________________
|   | USEFUL FUNCTION |
|   |_________________|
|__ getMaxInvertibleSubmatrix(A, [TOLERANCE])
        ----------------------------------------------
        *** Get invertible submatrix of any matrix ***
        ----------------------------------------------
        [in: A (matrix/2D array), TOLERANCE (float; default: 1E-4)
         return: a -- maximum non-singular submatrix of A. If A has
                      more (or same number of) rows than cols, then 
                      returns linearly independent (within TOLERANCE)
                      rows of A. Otherwise -- returns linearly-independent
                                                                      cols.
                      linearly-independent rows or cols are sorted in the
                      same order as they appear in A. Algorithm tries to
                      choose rows/cols with smallest, but nonzero (i.e.
                      >2*TOLERANCE) absolute values. 
                      NOTE: if all rows/cols are <=2*TOLERANCE then return
                            error code "ERROR: matrix elements too small"]








       
        
==================================
 ______________________________
|                              |
|  BIG CLASS: Circuit Builder  |
|______________________________|
|
| This class contains methods for
| building a circuit (calculating
| capacitance, inductance, etc. 
| matrices and flux/charge bias
| vectors) from formal code that
| is described at the end of the
| document
==================================
CircuitBuilder [class]
|__ SMALL
|      [Values less then SMALL will be considered zero. SMALL will be 
|       magnitude of parasitic capacitance]
|    __________
|   | SUBCLASS |
|   |__________|
|__ Circuit [class describing the circuit]
|   |__ Code    [list: Code describing the circuit structure]
|   |__ MutualInductanceCode    [list: Code describing mutual inductances]
|   |   [NOTE: code syntax described above]
|   |__ C       [Maxwell capacitance matrix]
|   |__ L       [Inductance matrix]
|   |__ E_jos   [row/column-vector of Josephson energies]
|   |__ extract(ElementType)
|   |       -----------------------------------------------------------
|   |       *** Extract elements of a certain type from the circuit ***
|   |       -----------------------------------------------------------
|   |       [in: ElementType (char: 'L', 'C' or 'J')
|   |        return: Code describing only subcircuit containing only elements
|   |                of type ElementType = 'L' -- extract inductors
|   |                                      'C' -- extract capacitors
|   |                                      'J' -- extract Josephson junctions]
|   |__ nElements()
|   |       ---------------------------------------------
|   |       *** Get number of elements in the circuit ***
|   |       ---------------------------------------------
|   |       [requires: Code
|   |        return: number of elements in circuit
|   |                                        (i.e. Number of rows in Code)]
|   |__ size():
|   |       ------------------------------------------
|   |       *** Get number of nodes in the circuit ***
|   |       ------------------------------------------
|   |       [requires: Code
|   |        return: number of nodes in the circuit]
|   |__ findElementNumber(self, Node1,Node2, ElementType)
|           -----------------------------------------------------------------
|           *** Find row in Circuit.Code that contains element connecting ***
|           *** the two nodes                                             ***
|           -----------------------------------------------------------------
|           [in: Node1 (int), Node2 (int), ElementType (char: 'L'/'C'/'J')
|            return: (int) find number (row number in Code) of a particular
|                          element of type ElementType=='L'/'C'/'J' and
|                          connecting nodes Node1 and Node2]
|
|__ setCapacitanceMatrix()
|       ----------------------------------------------------------
|       *** Calculate capacitance matrix based on Circuit.Code ***
|       ----------------------------------------------------------
|       [requires: Circuit
|        modifies: Circuit.C -- calculates Maxwell capacitance matrix. If the
|                               the capacitance matrix turns out to be 
|                               non-positive (as expected), then try to
|                               introduce SMALL parasitic capacitance. If not 
|                               successful, then return ]
|__ setInductanceMatrix()
|       -------------------------------------------------------------
|       *** Calculate inductance matrix based on Circuit.Code and ***
|       *** Circuit.MutualInductanceCode                          ***
|       -------------------------------------------------------------
|        [requires: Circuit (including Circuit.MutualInductanceCode)
|        modifies: Circuit.L -- calculates inductance matrix from code]
|__ setJosephsonEnergies()
|       ---------------------------------------------------
|       *** Obtain Josephson energies from Circuit.Code ***
|       ---------------------------------------------------
|       [requires: Circuit (Circuit.Code)
|        modifies: Circuit.E_jos -- extracts Josephson energies from Code]
|__ getInductorConnectivityMatrixG()
|       -------------------------------------------------------------
|       *** Obtain inductor connectivity matrix from Circuit.Code ***
|       -------------------------------------------------------------
|       [requires: Circuit (Circuit.Code)
|        return: G -- get inductor connectivity matrix from Code]
|__ getJosephsonConnectivityMatrixH()
|       --------------------------------------------------------------
|       *** Obtain Josephson connectivity matrix from Circuit.Code ***
|       --------------------------------------------------------------
|       [requires: Circuit (Circuit.Code)
|        return: H -- get Josephson connectivity matrix from Code]
|__ getFluxBiasVector(FluxBiasCode)
|       ----------------------------
|       *** Get flux bias vector ***
|       ----------------------------
|       [in: FluxBiasCode -- code describing flux biases (see syntax above)
|        return: Phi -- flux bias vector -- column-vector of flux biases
|                                                                in inductors]
|__ getChargeBiasVector(ChargeBiasCode)
|       ------------------------------
|       *** Get charge bias vector ***
|       ------------------------------
|       [in: ChargeBiasCode -- code describing charge biases (syntax above)
|        return: Q -- charge bias vector -- column-vector of charge biases
|                                                                in nodes]
|    __________________
|   | USEFUL FUNCTIONS |
|   |__________________|
|__ obtainConnectivityMatrix(Circuit, ElementType)
|       -------------------------------------------------------------------
|       *** Obtain connectivity matrix for an arbitrary type f elements ***
|       -------------------------------------------------------------------
|       [in: Circuit (Circuit property of CircuitBuilder),
|            ElementType (char = 'L'/'C'/'J') -- type of element
|                                                we want to extract
|        return: Connectivity Matrix (matrix that converts phases on 
|                                     nodes to phase drops across 
|                                     chosen types of elements)]
|
|__ convertMutualMaxwellCapMat(C)
|       ------------------------------------------------------------------
|       *** Convert mutual capacitance matrix into Maxwell cap. matrix ***
|       *** and vice versa (this transform is self-inverse)            ***
|       ------------------------------------------------------------------
|       [in: C -- mutual or Maxwell capacitance matrix
|        return: Maxwell or mutual capacitance matrix.
|                Function converts mutual cap. matrix
|                into Maxwell cap. matrix and vice versa]
|__ inv_sqrt(C, SMALL)
        -------------------------------------------------------------
        *** Get inverse square root of Maxwell capacitance matrix ***
        *** If cap. matrix is not positive, try to fix            ***
        -------------------------------------------------------------
        [Used to calculate inverse square root of capacitance matrix
         in C (square matrix), SMALL (positive float: small parameter)
         return: C**(-1/2) -- inverse square root of matrix C.
                 NOTE: C needs to be a symmetric, real and positively-defined
                                                                       matrix.
                       If C is not symmetric then return
                                             "ERROR: Matrix is not symmetric".
                       If C is not real-valued then return
                                        "ERROR: Matrix is not symmetric real". 
                       If C is not positively-defined then.
                           First: try to fix it by adding SMALL positive value
                                  to the eigenvalues of C (parasitic cap.)
                           Second: if fixing did not work (if C is still not 
                                   positive, then return error message:
                                "ERROR: Matrix is non-positive. Couldn't fix".]
            
            



    
    
    
    
    

=============================
 _________________________
|                         |
|  BIG CLASS: Easy Model  |
|_________________________|
|
| This class contains methods
| for simplified building
| and solving the model. It 
| automatically performs
| sequences of operations to
| build and calculate the
| model.
=============================
EasyModel(SMALL, CircuitCode, MutualInductanceCode) [class]
|   --------------------------------------------------------------------------
|   *** Class that automatizes calculations. Performs operations in needed ***
|   *** sequence and looks for errors                                      ***
|   --------------------------------------------------------------------------
|   [in order to create object of this class need
|    to define: SMALL parameter,
|               CircuitCode -- code describing the circuit,
|               MutualInductanceCode -- code describing mutual inductances]
|
|__ SMALL   [positive float: small parameter used in the model. 
|            Will be the value of parasitic capacitances and 
|            will be used to compare collinearity of vectors.
|                                          Default value: 1E-4]
|__ MESSAGE_ARRAY   [this list will contain messages generated 
|                                          during calculations]
|__ DISPLAY     [bool: determines if messages will be displayed on the screen.
|                      Default value: True. Messages are always saved in
|                                                          MESSAGE_ARRAY.]
|__ ENFORCE_INT_IN_Z_CYC    [This property determines if we want to force
|                                 Z_cyc-matrix to be forced to be integer.]
|__ DEBUG_DATA  [set/dict that contains values of most essential parameters
|                of the model. Updated while calculating circuit parameters
|                and while calculating matrices. This data is useful for 
|                                                                debugging]
|    __________
|   | SUBCLASS |
|   |__________|
|__ SQM [class that contains CircuitBuilder and ModelCalculator objects]
|   |__ CircBuild [object of class CircuitBuilder]
|   |__ ModelCalc [object of class ModelCalculator]
|
|    __________
|   | SUBCLASS |
|   |__________|
|__ Code [class that contains codes describing all circuit parameters]
|   |__ CircuitCode [list: Code describing circuit structure]
|   |__ MutualInductanceCode [list: Code describing mutual inductances]
|   |__ FluxBiasCode [list: Code describing flux biases]
|   |__ ChargeBiasCode [list: Code describing charge biases]
|
|__ printMessage(Message)
|       -------------------------------------------------------------
|       *** Print function which also saves data in MESSAGE_ARRAY ***
|       -------------------------------------------------------------
|       [in: Message (str)
|        requires: DISPLAY
|        modifies: MESSAGE_ARRAY -- adds Message to MESSAGE_ARRAY.
|                  If DISPLAY option is True then also display Message on
|                                                              the screen]
|__ buildCircuit()
|       ----------------------------------------------------------------------
|       *** Perform operations to get circuit parameters from Circuit Code ***
|       *** and Mutual Inductance Code                                     ***
|       ----------------------------------------------------------------------
|       [requires: Code.CircuitCode, Code.MutualInductanceCode, SMALL
|        modifies: SQM.CircBuild -- creates object containing essential
|                                                    circuit parameters
|                  MESSAGE_ARRAY -- saves calculation progress]
|__ transformCoordinates()
|       ---------------------------------------------------------------
|       *** Perform transformations I & II to build the Hamiltonian ***
|       ---------------------------------------------------------------
|       [requires: SQM.CircBuild, SMALL
|        modifies: SQM.ModelCalc -- creates ModelCalculator object and 
|                                   performs coordinate transformations
|                                   inside ModelCalc. But at this point
|                                   we do not modify SQM.ModelCalc.Operators.]
|__ transformBiasVectors(FluxBiasCode, ChargeBiasCode)
|       ---------------------------------------------------------
|       *** Obtained transformed flux and charge bias vectors ***
|       ---------------------------------------------------------
|       [in: FluxBiasCode, ChargeBiasCode (lists containing codes for 
|                                                      flux and charge biases)
|        modifies: Code.FluxBiasCode, Code.ChargeBiasCode,
|                  SQM.ModelCalc.Circuit.Phi, SQM.ModelCalc.Circuit.Q
|                      -- calculates flux and charge bias vectors and saves
|                                         corresponding codes in Code object]
|__ summarizeCoord()
|       ---------------------------------------------------------
|       *** Print summary of coordinates and mode frequencies ***
|       ---------------------------------------------------------
|       [requires: SQM.ModelCalc.Matrices, DISPLAY
|        modifies: MESSAGE_ARRAY -- adds coordinate summary.
|                  coordinate summary contains number of cyclic
|                  and oscillatory coordinates and their mode frequencies.
|                  If DISPLAY is True then also print coordinate on screen]
|
|__ set_N_of_states(N_of_states)
|       ------------------------------------------------------------------
|       *** Set numbers of quantum states for each coordinate to later ***
|       *** obtain quantum operators                                   ***
|       ------------------------------------------------------------------
|       [in: N_of_states (list: list of number of states for each quantum
|                                                                 coordinate)
|        modifies: SQM.ModelCalc.Operators.N_of_states -- sets N_of_states.]
|
|__ setOperators()
|       -----------------------------------
|       *** Calculate quantum operators ***
|       -----------------------------------
|       [requires: SQM.ModelCalc.Matrices, SQM.ModelCalc.Operators.N_of_states
|        modifies: obtains lists of quantum  operators:
|                                             SQM.ModelCalc.Operators.I_hat,
|                                             SQM.ModelCalc.Operators.N_hat,
|                                             SQM.ModelCalc.Operators.V_hat.]
|__ setHamiltonian()
|       --------------------------
|       *** Obtain Hamiltonian ***
|       --------------------------
|       [requires: SQM.ModelCalc.Matrices, SQM.ModelCalc.Circuit,
|                  SQM.ModelCalc.Operators
|        modifies: calculates Hamiltonian and saves in
|                                        SQM.ModelCalc.Operators.Hamiltonian.]
|__ getHamiltonian()
        -------------------------------------
        *** Return calculated Hamiltonian ***
        -------------------------------------
        [requires: SQM.ModelCalc.Operators.Hamiltonian
         return: the Hamiltonian SQM.ModelCalc.Operators.Hamiltonian.]








==================================================
 ______________
|              |
|   N O T E !  |
|______________|
|
| 1. All objects, classes and subclasses
|    represent themselves by displaying their 
|    internal structure: properties and methods
|    (dir) with attributes not starting with "_"
| 2. Properties that were not set or
|    calculated yet are typically set 
|    to None or [None] or numpy.matrix([[None]]) or
|    empty list [] by default.
==================================================
